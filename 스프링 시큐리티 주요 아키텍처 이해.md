> 본 게시물은 스스로의 공부를 위한 글입니다.
> 잘못된 내용이 있으면 댓글로 알려주세요!



---

####  Reference

인프런 '스프링 시큐리티 - Spring Boot 기반으로 개발하는 Spring Security' (정수원)





### DelegatingProxyChain

Spring Bean은 Servlet Filter에 Injection이 불가능하다. (컨테이너가 서로 다르기 때문이다.)

그럼 스프링으로 만든 필터와 Servlet Filter을 어떻게 연결할까? 바로 DelegatingFilterProxy이다.

DelegatingFilterProxy는 Servlet Filter이다. 요청을 받게되면 Spring Bean에게 요청을 위임하게 된다.

따라서 Spring 기술도 사용하면서 Filter역할로도 사용할 수 있게 된다.

만약 스프링 시큐리티를 사용한다면 springSecurityFilterChain으로 생성된 빈을 ApplicationContext에서 찾아서 요청을 위임하게 된다.





### FilterChainProxy

springSecurityFilterChain으로 생성되는 필터 빈은 FilterChainProxy이다.

즉, DelegatingFilterProxy에게 요청을 위임 받고 실제 보안 처리를 하는 필터이다.



스프링 시큐리티가 기본적으로 생성하는 필터도 있고, 설정 클래스에서 사용자가 API 추가 시 생성되는 필터도 있다.

필터들은 Chain으로 연결되어 있기 때문에, 사용자의 요청을 필터 순서대로 호출하여 전달하게 된다.

물론 사용자 정의 필터를 생성해서 기존의 필터 전, 후로 추가할 수 있다.

마지막 필터까지 인증 및 인가 예외가 발생하지 않으면 보안이 통과하게 된다. 즉, Servlet으로 넘어가게 된다.





![스크린샷 2022-02-20 오후 11.42.38](/Users/hongseungtaeg/Desktop/스크린샷 2022-02-20 오후 11.42.38.png)





### 필터 초기화와 다중 설정 클래스

보안 설정 파일을 분리해서 여러개 작성할 수 있다.
그러면 FilterChainProxy에 필터들이 List형태로 들어가게 되는데, 순서대로 설정파일의  RequestMacher와 현재 요청한 url이 부합한지 확인한다. 만약 적용 대상이라면 해당 필터를 진행하게 된다.




#### 실전코드

설정 클래스를 2개 작성해보자.

```java
@Configuration
@EnableWebSecurity
@Order(0)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .antMatcher("/admin/**")
                .authorizeRequests()
                .anyRequest().authenticated()
        .and()
                .httpBasic();

    }
}

@Configuration
@Order(1)
class SecurityConfig2 extends WebSecurityConfigurerAdapter{
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()
                .anyRequest().permitAll()
                .and()
                .formLogin();
    }
}

```


FilterChainProxy에서 `List<Filter> getFilters(HttpServletRequest request)`에 break point를 놓고 디버깅을 해보면 아래와 같이 필터 체인 리스트에 우리가 등록한 2개의 필터가 넣어져 있는 것을 확인할 수 있다.

![스크린샷 2022-02-21 오전 11.00.43](/Users/hongseungtaeg/Desktop/inflearn spring security/스크린샷 2022-02-21 오전 11.00.43.png)



`requestMatcher`을 보면 Index 0에는 `pattern=‘/admin/**’`가 있고, Index 1에는 `any request`가 있다. 스프링 시큐리티는 for 문을 돌면서 해당 pattern에 맞는 필터를 찾아 리턴하게 된다.

설정 클래스를 보면 `@Order( 숫자 )`를 찾을 수 있다. 숫자가 작을 수록 우선순위가 높은건데, 필터 체인 리스트에 들어가는 순서이다.

다음과 같은 예시를 보자.
@Order(0) config1 : antMatcher(“/admin”)
@Order(1) config2 : anyRequest

1. `/admin`으로 접속 : config1 실행
2. `/`으로 접속 : config2 실행


@Order(1) config1 : antMatcher(“/admin”)
@Order(0) config2 : anyRequest

1. `/admin`으로 접속 : config1 실행
2. `/`으로 접속 : config1 실행




먼저 부합하는 필터 체인을 실행하기 때문에 @Order로 순서를 정하는 것이 중요하다. (어노테이션이 없으면 오류난다.) 주로 좁은 범위(구체적인 경로)에게 우선순위를 높게 주는것이 일반적이다.


사실 하나의 SecurityConfig로도 구성이 가능하기는 하다만, 설정 클래스를 여러개로 나눔으로써 확장성 면에서 이점이 있다. 인증 방식을 완전히 다른 방식으로 설정하거나, 여러가지 필터나 보안 옵션 또한 다양하게 설정이 가능하다. 사용자 보안과 관리자 보안을 나누거나 도메인 별로 나누어서 관리할 수 있다.









### Authentication(인증 객체)

사용자의 인증 정보를 저장하는 토큰 개념.

2가지 용도로 사용된다. `인증 용도` 또는 `인증 후 세션에 담기 위한 용도`

1. 인증시 id와 password를 담고 인증 검증을 위해 전달되어 사용된다.

2. 인증 후 최종 인증 결과(user 객체, 권한 정보)를 담고 SecurityContext에 저장되어 전역적으로 참조가 가능하다.

`Authentication authentication = SecurityContexHolder.getContext().getAuthentication()`



구조

1. Principal(Object 타입): 사용자 아이디 혹은 User 객체를 저장
2. Credentials: 사용자 비밀번호
3. authorities: 인증된 사용자의 권한 목록
4. details: 인증 부과 정보
5. Authenticated: 인증 여부





Authentication은 인터페이스이므로 구현체가 따로 존재한다. 물론 사용자가 직접 커스텀도 가능하다. 대표적으로 `UsernamepPasswordAuthenticationFilter`이 있다.







### SecurityContext

- Authentication 객체가 저장되는 보관소로 필요 시 언제든지 Authentication 객체를 꺼내어 쓸 수 있도록 제공되는 클래스
- ThreadLocal에 저장되어 아무 곳에서나 참조가 가능하도록 설계함
- 인증이 완료되면 HttpSession에 저장되어 어플리케이션 전반에 걸쳐 전역적인 참조가 가능하다.



### SecurityContextHolder

- SecurityContext 객체 저장 방식
  - MODE_THREADLOCAL: 스레드당 SecurityContext 객체를 할당, 기본값
    - 자식 쓰레드와는 공유가 되지 않는다. 공유를 하려면 아래 모드로 변환을 해야한다.
  - MODE_INHERITABLETHREADLOCAL: 메인 스레드와 자식 스레드에 관하여 동일한 SecurityContext를 유지
  - MODE_GLOBAL: 응용 프로그램에서 단 하나의 SecurityContext를 저장한다.
- 객체 저장 방식은 보안 설정 클래스에서 `SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL)`  설정으로 바꿀 수 있다.
- SecurityContextHolder.clearContext(): SecurityContext 기존 정보 초기화



전역적으로 다음과 같은 코드로 인증 객체를 얻을 수 있다.

`Authentication authentication = SecurityContextHolder.getContext().getAuthentication()`

어차피 SecurityContext가 세션에 저장되기 때문에 세션->SecurityContext-> 인증객체를 찾아도 괜찮다.



```java
@GetMapping()
public String index(HttpSession session){
  Authentication authentication1 = SecurityContextHolder.getContext().getAuthentication()
  SecurityContext context = (SecurityContext)session.getAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY);
  Authenticatino authentication2 = context.getAuthentication();
  
  // authentication1 == authentication2 이다.
}
```



![스크린샷 2022-02-21 오후 11.43.32](/Users/hongseungtaeg/Desktop/inflearn spring security/스크린샷 2022-02-21 오후 11.43.32.png)













### SecurityContextPersistenceFilter

SecurityContext 객체의 생성, 저장, 조회하는 필터이다.

1. 익명 사용자

- 새로운 SecurityContext 객체를 생성하여 SecurityContextHolder에 저장한다.
- AnonmousAuthenticationFilter에서 AnonymousAuthenticationToken 객체를 SecurityContext에 저장한다.



2. 인증 시

- 새로운 SecurityContext 객체를 생성하여 SecurityContextHolder에 저장
- UsernamePasswordAuthenticationFilter에서 인증 성공 후 SecurityContext에 UsernamePasswordAuthenticationToken 객체를 SecurityContext에 저장한다.
- 인증이 최종 완료되면 Session에 SecurityContext를 저장한다.



3. 인증 후

- Session에서 SecurityContext를 꺼내에 SecurityContextHolder에 저장한다.
- SecurityContext 안에 Authentication 객체가 존재하면 계속 인증을 유지한다.



4. 최종 응답 시 공통

- SecurityContextHolder.clearContext()

![스크린샷 2022-02-22 오후 11.30.24](/Users/hongseungtaeg/Desktop/inflearn spring security/스크린샷 2022-02-22 오후 11.30.24.png)